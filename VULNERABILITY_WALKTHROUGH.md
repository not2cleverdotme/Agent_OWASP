# üîç Vulnerability Walkthrough Guide

**‚ö†Ô∏è FOR EDUCATIONAL PURPOSES ONLY**

This guide provides step-by-step instructions for understanding and solving each vulnerability in the Vulnerable Agentic Agent.

## üìã Table of Contents

1. [SQL Injection](#sql-injection)
2. [Command Injection](#command-injection)
3. [SSRF (Server-Side Request Forgery)](#ssrf)
4. [Weak Authentication](#weak-authentication)
5. [Information Disclosure](#information-disclosure)
6. [File Upload Vulnerabilities](#file-upload-vulnerabilities)
7. [Agent Task Execution Vulnerabilities](#agent-task-execution-vulnerabilities)

---

## 1. SQL Injection

### üéØ Objective
Extract sensitive data from the database using SQL injection attacks.

### üìç Vulnerable Endpoint
```
GET /api/user_data?user_id=<payload>
```

### üîç Understanding the Vulnerability

**Vulnerable Code:**
```python
def execute_sql_query(query):
    conn = sqlite3.connect('vulnerable_agent.db')
    cursor = conn.cursor()
    # VULNERABLE: Direct string concatenation
    cursor.execute(query)
    result = cursor.fetchall()
    conn.close()
    return result

@app.route('/api/user_data', methods=['GET'])
def get_user_data():
    user_id = request.args.get('user_id')
    # VULNERABLE: SQL Injection
    query = f"SELECT * FROM user_data WHERE user_id = {user_id}"
    result = execute_sql_query(query)
    return jsonify(result)
```

**Problem**: The application directly concatenates user input into SQL queries without validation or sanitization.

### üß™ Step-by-Step Exploitation

#### Step 1: Basic SQL Injection
1. **Open the web interface**: Go to `http://localhost:8080`
2. **Navigate to "Vulnerability Tests" tab**
3. **Find the SQL Injection section**
4. **Try this payload**: `1 OR 1=1`
5. **Click "Test SQL Injection"**
6. **Expected Result**: Should return all data from the table

**What's happening:**
- Original query: `SELECT * FROM user_data WHERE user_id = 1`
- Injected query: `SELECT * FROM user_data WHERE user_id = 1 OR 1=1`
- The `OR 1=1` makes the condition always true, returning all records

#### Step 2: Union Attack
1. **Try this payload**: `1 UNION SELECT * FROM users --`
2. **Click "Test SQL Injection"**
3. **Expected Result**: Should return data from the users table

**What's happening:**
- The `UNION` operator combines results from two SELECT statements
- `--` comments out the rest of the original query
- This reveals the users table structure and data

#### Step 3: Database Enumeration
1. **Try this payload**: `1 UNION SELECT name FROM sqlite_master WHERE type='table' --`
2. **Expected Result**: Should show all table names in the database

### üîß How to Fix

**Secure Code:**
```python
@app.route('/api/user_data', methods=['GET'])
def get_user_data():
    user_id = request.args.get('user_id')
    
    # Input validation
    if not user_id or not user_id.isdigit():
        return jsonify({'error': 'Invalid user_id'}), 400
    
    # Use parameterized query
    conn = sqlite3.connect('vulnerable_agent.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM user_data WHERE user_id = ?", (user_id,))
    result = cursor.fetchall()
    conn.close()
    
    return jsonify(result)
```

**Key Security Measures:**
1. **Input Validation**: Check if input is numeric
2. **Parameterized Queries**: Use placeholders instead of string concatenation
3. **Error Handling**: Don't expose database errors to users

---

## 2. Command Injection

### üéØ Objective
Execute system commands through the application.

### üìç Vulnerable Endpoint
```
POST /api/execute
Content-Type: application/json
{"command": "<payload>"}
```

### üîç Understanding the Vulnerability

**Vulnerable Code:**
```python
@app.route('/api/execute', methods=['POST'])
def execute_command():
    command = request.json.get('command')
    
    # VULNERABLE: Command Injection
    # No input validation or sanitization
    try:
        result = subprocess.check_output(command, shell=True, text=True)
        return jsonify({'result': result})
    except Exception as e:
        return jsonify({'error': str(e)}), 500
```

**Problem**: The application executes user input as system commands without validation.

### üß™ Step-by-Step Exploitation

#### Step 1: Basic Command Execution
1. **Go to "Vulnerability Tests" tab**
2. **Find the Command Injection section**
3. **Try this command**: `whoami`
4. **Click "Test Command Injection"**
5. **Expected Result**: Should show the current user

#### Step 2: Multiple Commands
1. **Try this command**: `ls -la; cat /etc/passwd`
2. **Expected Result**: Should list files and show password file

**What's happening:**
- `;` separates multiple commands
- The shell executes both commands sequentially

#### Step 3: Advanced Exploitation
1. **Try this command**: `ls -la && cat /etc/passwd`
2. **Try this command**: `ls -la || echo "Command failed"`
3. **Try this command**: `$(whoami)`

### üîß How to Fix

**Secure Code:**
```python
@app.route('/api/execute', methods=['POST'])
def execute_command():
    command = request.json.get('command')
    
    # Input validation
    if not command:
        return jsonify({'error': 'No command provided'}), 400
    
    # Whitelist allowed commands
    allowed_commands = ['ls', 'pwd', 'whoami']
    command_parts = command.split()
    
    if command_parts[0] not in allowed_commands:
        return jsonify({'error': 'Command not allowed'}), 403
    
    try:
        # Use shell=False and pass command as list
        result = subprocess.check_output(command_parts, shell=False, text=True)
        return jsonify({'result': result})
    except Exception as e:
        return jsonify({'error': 'Command execution failed'}), 500
```

**Key Security Measures:**
1. **Command Whitelisting**: Only allow specific commands
2. **Shell=False**: Don't use shell interpretation
3. **Input Validation**: Validate command structure
4. **Error Handling**: Don't expose system errors

---

## 3. SSRF (Server-Side Request Forgery)

### üéØ Objective
Make the server request internal services or files.

### üìç Vulnerable Endpoint
```
POST /api/fetch_url
Content-Type: application/json
{"url": "<payload>"}
```

### üîç Understanding the Vulnerability

**Vulnerable Code:**
```python
@app.route('/api/fetch_url', methods=['POST'])
def fetch_url():
    url = request.json.get('url')
    
    # VULNERABLE: SSRF - No URL validation
    try:
        response = requests.get(url, timeout=5)
        return jsonify({
            'status_code': response.status_code,
            'content': response.text[:1000]
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500
```

**Problem**: The application fetches any URL without validation, allowing access to internal services.

### üß™ Step-by-Step Exploitation

#### Step 1: Internal Service Access
1. **Go to "Vulnerability Tests" tab**
2. **Find the SSRF section**
3. **Try this URL**: `http://localhost:8080/api/debug`
4. **Click "Test SSRF"**
5. **Expected Result**: Should return debug information

#### Step 2: Port Scanning
1. **Try this URL**: `http://127.0.0.1:22`
2. **Expected Result**: Should show connection error (port 22 is SSH)

#### Step 3: File Reading Attempt
1. **Try this URL**: `file:///etc/passwd`
2. **Expected Result**: Should show error (requests library doesn't support file://)

### üîß How to Fix

**Secure Code:**
```python
@app.route('/api/fetch_url', methods=['POST'])
def fetch_url():
    url = request.json.get('url')
    
    # URL validation
    if not url:
        return jsonify({'error': 'No URL provided'}), 400
    
    # Whitelist allowed domains
    allowed_domains = ['api.example.com', 'public-api.com']
    parsed_url = urllib.parse.urlparse(url)
    
    if parsed_url.scheme not in ['http', 'https']:
        return jsonify({'error': 'Invalid URL scheme'}), 400
    
    if parsed_url.netloc not in allowed_domains:
        return jsonify({'error': 'Domain not allowed'}), 403
    
    # Block internal IPs
    if parsed_url.netloc.startswith(('127.', '10.', '192.168.', '172.')):
        return jsonify({'error': 'Internal IPs not allowed'}), 403
    
    try:
        response = requests.get(url, timeout=5)
        return jsonify({
            'status_code': response.status_code,
            'content': response.text[:1000]
        })
    except Exception as e:
        return jsonify({'error': 'Request failed'}), 500
```

**Key Security Measures:**
1. **URL Validation**: Check URL scheme and structure
2. **Domain Whitelisting**: Only allow specific domains
3. **Internal IP Blocking**: Block access to internal networks
4. **Timeout Limits**: Prevent long-running requests

---

## 4. Weak Authentication

### üéØ Objective
Bypass weak authentication mechanisms.

### üìç Vulnerable Endpoint
```
POST /login
Content-Type: application/x-www-form-urlencoded
username=<username>&password=<password>
```

### üîç Understanding the Vulnerability

**Vulnerable Code:**
```python
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        # VULNERABLE: Weak password comparison
        if username == ADMIN_USERNAME and password == ADMIN_PASSWORD:
            session['user_id'] = 1
            session['username'] = username
            session['role'] = 'admin'
            return redirect(url_for('dashboard'))
        else:
            return "Invalid credentials", 401
```

**Problems:**
1. Hardcoded credentials
2. Weak password (admin123)
3. No rate limiting
4. No session timeout

### üß™ Step-by-Step Exploitation

#### Step 1: Default Credentials
1. **Go to "Login" tab**
2. **Enter username**: `admin`
3. **Enter password**: `admin123`
4. **Click "Login"**
5. **Expected Result**: Should successfully log in

#### Step 2: Brute Force Attempt
1. **Try common passwords**: `admin`, `password`, `123456`
2. **Try username variations**: `admin`, `Admin`, `ADMIN`

### üîß How to Fix

**Secure Code:**
```python
import bcrypt
from datetime import datetime, timedelta

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        # Rate limiting
        if is_rate_limited(request):
            return "Too many login attempts", 429
        
        # Get user from database
        user = get_user_by_username(username)
        if user and bcrypt.verify(password, user['password_hash']):
            # Set session with timeout
            session['user_id'] = user['id']
            session['username'] = user['username']
            session['role'] = user['role']
            session['login_time'] = datetime.utcnow()
            return redirect(url_for('dashboard'))
        else:
            return "Invalid credentials", 401

def is_rate_limited(request):
    # Implement rate limiting logic
    pass

def get_user_by_username(username):
    # Get user from database with proper validation
    pass
```

**Key Security Measures:**
1. **Strong Password Hashing**: Use bcrypt or Argon2
2. **Rate Limiting**: Prevent brute force attacks
3. **Session Management**: Implement proper session timeouts
4. **Database Storage**: Store credentials securely in database

---

## 5. Information Disclosure

### üéØ Objective
Access sensitive configuration and debug information.

### üìç Vulnerable Endpoint
```
GET /api/debug
```

### üîç Understanding the Vulnerability

**Vulnerable Code:**
```python
@app.route('/api/debug')
def debug_info():
    # VULNERABLE: Exposing sensitive information
    return jsonify({
        'database_path': 'vulnerable_agent.db',
        'upload_directory': 'uploads',
        'secret_key': app.config['SECRET_KEY'],
        'jwt_secret': JWT_SECRET,
        'admin_credentials': f'{ADMIN_USERNAME}:{ADMIN_PASSWORD}',
        'server_info': {
            'python_version': os.sys.version,
            'working_directory': os.getcwd(),
            'environment_variables': dict(os.environ)
        }
    })
```

**Problem**: The application exposes sensitive configuration information.

### üß™ Step-by-Step Exploitation

#### Step 1: Access Debug Information
1. **Go to "Debug Info" tab**
2. **Click "Get Debug Info"**
3. **Review the exposed information**

#### Step 2: Use Exposed Information
1. **Note the admin credentials**: `admin:admin123`
2. **Note the JWT secret**: `weak_jwt_secret`
3. **Note the database path**: `vulnerable_agent.db`

### üîß How to Fix

**Secure Code:**
```python
# Remove debug endpoint entirely in production
# Or implement proper access controls

@app.route('/api/debug')
def debug_info():
    # Only allow in development
    if not app.debug:
        return jsonify({'error': 'Debug endpoint disabled'}), 404
    
    # Only allow authenticated admin users
    if not is_authenticated_admin():
        return jsonify({'error': 'Unauthorized'}), 401
    
    # Return minimal information
    return jsonify({
        'status': 'running',
        'version': '1.0.0',
        'timestamp': datetime.utcnow().isoformat()
    })

def is_authenticated_admin():
    # Implement proper authentication check
    pass
```

**Key Security Measures:**
1. **Disable in Production**: Remove debug endpoints
2. **Access Control**: Require authentication
3. **Minimal Information**: Only expose necessary data
4. **Environment Checks**: Disable based on environment

---

## 6. File Upload Vulnerabilities

### üéØ Objective
Upload malicious files to the server.

### üìç Vulnerable Endpoint
```
POST /api/upload
Content-Type: multipart/form-data
```

### üîç Understanding the Vulnerability

**Vulnerable Code:**
```python
@app.route('/api/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'No file provided'}), 400
    
    file = request.files['file']
    
    # VULNERABLE: No file type validation
    # VULNERABLE: No file size limits
    # VULNERABLE: Unsafe file path
    filename = file.filename
    file_path = os.path.join('uploads', filename)
    
    file.save(file_path)
    return jsonify({'message': f'File uploaded successfully: {filename}'})
```

**Problems:**
1. No file type validation
2. No file size limits
3. Unsafe file path handling
4. No content validation

### üß™ Step-by-Step Exploitation

#### Step 1: Upload Malicious File
1. **Go to "Vulnerability Tests" tab**
2. **Find the File Upload section**
3. **Create a file with malicious content**
4. **Upload the file**
5. **Expected Result**: File should upload successfully

#### Step 2: Path Traversal
1. **Try uploading a file named**: `../../../etc/passwd`
2. **Expected Result**: Should attempt to write outside upload directory

### üîß How to Fix

**Secure Code:**
```python
import os
import magic
from werkzeug.utils import secure_filename

ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}
MAX_FILE_SIZE = 16 * 1024 * 1024  # 16MB

@app.route('/api/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'No file provided'}), 400
    
    file = request.files['file']
    
    # Check file size
    file.seek(0, os.SEEK_END)
    file_size = file.tell()
    file.seek(0)
    
    if file_size > MAX_FILE_SIZE:
        return jsonify({'error': 'File too large'}), 400
    
    # Validate file type
    if not allowed_file(file.filename):
        return jsonify({'error': 'File type not allowed'}), 400
    
    # Secure filename
    filename = secure_filename(file.filename)
    if not filename:
        return jsonify({'error': 'Invalid filename'}), 400
    
    # Create safe file path
    upload_dir = os.path.join(os.getcwd(), 'uploads')
    os.makedirs(upload_dir, exist_ok=True)
    file_path = os.path.join(upload_dir, filename)
    
    # Ensure path is within upload directory
    if not os.path.abspath(file_path).startswith(os.path.abspath(upload_dir)):
        return jsonify({'error': 'Invalid file path'}), 400
    
    # Save file
    file.save(file_path)
    return jsonify({'message': f'File uploaded successfully: {filename}'})

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
```

**Key Security Measures:**
1. **File Type Validation**: Check file extensions and content
2. **File Size Limits**: Prevent large file uploads
3. **Secure Filenames**: Use secure_filename()
4. **Path Validation**: Prevent directory traversal
5. **Content Scanning**: Scan for malicious content

---

## 7. Agent Task Execution Vulnerabilities

### üéØ Objective
Exploit the agent's task execution functionality.

### üìç Vulnerable Endpoint
```
POST /api/agent/execute
Content-Type: application/json
{"task": "<task>", "user_id": <user_id>}
```

### üîç Understanding the Vulnerability

**Vulnerable Code:**
```python
@app.route('/api/agent/execute', methods=['POST'])
def agent_execute():
    task = request.json.get('task')
    user_id = request.json.get('user_id')
    
    # VULNERABLE: No input validation
    # VULNERABLE: Command injection possible
    # VULNERABLE: No authentication required
    
    if task.startswith('system:'):
        command = task[7:]  # Remove 'system:' prefix
        try:
            result = subprocess.check_output(command, shell=True, text=True)
            return jsonify({'result': result, 'type': 'system_command'})
        except Exception as e:
            return jsonify({'error': str(e)}), 500
```

**Problems:**
1. No authentication required
2. Command injection through system: prefix
3. SQL injection through sql: prefix
4. SSRF through fetch: prefix

### üß™ Step-by-Step Exploitation

#### Step 1: System Command Execution
1. **Go to "Agent Interface" tab**
2. **Enter task**: `system:whoami`
3. **Click "Execute Task"**
4. **Expected Result**: Should show current user

#### Step 2: SQL Injection Through Agent
1. **Enter task**: `sql:SELECT * FROM users`
2. **Click "Execute Task"**
3. **Expected Result**: Should return user data

#### Step 3: SSRF Through Agent
1. **Enter task**: `fetch:http://localhost:8080/api/debug`
2. **Click "Execute Task"**
3. **Expected Result**: Should return debug information

### üîß How to Fix

**Secure Code:**
```python
@app.route('/api/agent/execute', methods=['POST'])
def agent_execute():
    # Authentication required
    if not is_authenticated():
        return jsonify({'error': 'Authentication required'}), 401
    
    task = request.json.get('task')
    user_id = request.json.get('user_id')
    
    # Input validation
    if not task or not user_id:
        return jsonify({'error': 'Missing required parameters'}), 400
    
    # Validate user_id
    if not str(user_id).isdigit():
        return jsonify({'error': 'Invalid user_id'}), 400
    
    # Task type validation
    if task.startswith('system:'):
        return execute_system_task(task[7:], user_id)
    elif task.startswith('sql:'):
        return execute_sql_task(task[4:], user_id)
    elif task.startswith('fetch:'):
        return execute_fetch_task(task[6:], user_id)
    else:
        return jsonify({'error': 'Invalid task type'}), 400

def execute_system_task(command, user_id):
    # Whitelist allowed commands
    allowed_commands = ['whoami', 'pwd', 'ls']
    if command not in allowed_commands:
        return jsonify({'error': 'Command not allowed'}), 403
    
    try:
        result = subprocess.check_output([command], shell=False, text=True)
        return jsonify({'result': result, 'type': 'system_command'})
    except Exception as e:
        return jsonify({'error': 'Command execution failed'}), 500

def execute_sql_task(query, user_id):
    # Use parameterized queries
    # Implement proper SQL validation
    pass

def execute_fetch_task(url, user_id):
    # Implement URL validation and allowlisting
    pass
```

**Key Security Measures:**
1. **Authentication**: Require proper authentication
2. **Input Validation**: Validate all inputs
3. **Command Whitelisting**: Only allow specific commands
4. **Task Type Validation**: Validate task types
5. **Error Handling**: Don't expose system errors

---

## üéì Learning Summary

### Key Security Principles

1. **Input Validation**: Always validate and sanitize user input
2. **Authentication**: Implement proper authentication and authorization
3. **Least Privilege**: Only allow necessary permissions
4. **Defense in Depth**: Use multiple security layers
5. **Secure by Default**: Default to secure configurations
6. **Error Handling**: Don't expose sensitive information in errors
7. **Regular Updates**: Keep dependencies and systems updated

### Common Attack Vectors

1. **Injection Attacks**: SQL, Command, LDAP, XPath
2. **Authentication Bypass**: Weak passwords, session hijacking
3. **Information Disclosure**: Debug info, error messages
4. **File Upload**: Malicious files, path traversal
5. **SSRF**: Internal service access
6. **CSRF**: Cross-site request forgery
7. **XSS**: Cross-site scripting

### Secure Development Practices

1. **Use Security Frameworks**: Leverage built-in security features
2. **Code Reviews**: Regular security code reviews
3. **Penetration Testing**: Regular security testing
4. **Security Training**: Educate developers on security
5. **Incident Response**: Have a plan for security incidents

---

**Remember**: This guide is for educational purposes. Use this knowledge to build more secure applications and protect against real-world attacks. 